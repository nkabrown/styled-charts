// License MIT Copyright 2019 Caleb Williams https://github.com/calebdwilliams/construct-style-sheets
(function(){"use strict";const e="adoptedStyleSheets"in document;if(!e){function t(e){return e.replace(/\s/g,"").match(/\@import/)}function o(o){if(t(o)){throw new Error("@import is not allowed when using CSSStyleSheet's replaceSync method")}if(this[e]){this[e]._sheet.innerHTML=o;y(this);return this[e]._sheet.sheet}else{throw new TypeError("replaceSync can only be called on a constructed style sheet")}}function s(t){return new Promise((o,s)=>{if(this[e]){this[e]._sheet.innerHTML=t;o(this[e]._sheet.sheet);y(this)}else{s("replace can only be called on a constructed style sheet")}})}const e=Symbol("constructible style sheets");const r=Symbol("constructed");const c=Symbol("obsolete");const h=document.createElement("iframe");const d=Symbol("Styles");const i=t=>{t.forEach(t=>{const{addedNodes:o,removedNodes:s}=t;s.forEach(e=>{if(e[r]&&!e[c]){setTimeout(()=>{e[r].appendChild(e)})}});o.forEach(t=>{const{shadowRoot:o}=t;if(o&&o.adoptedStyleSheets){o.adoptedStyleSheets.forEach(t=>{o.appendChild(t[e]._sheet)})}})})};const l=new MutationObserver(i);l.observe(document.body,{childList:true});h.hidden=true;document.body.appendChild(h);const p=h.contentWindow.document.body;const a=(t,o)=>{const s=o[e]._sheet.cloneNode(true);t.body?t=t.body:null;s[r]=t;o[e]._adopters.push({location:t,clone:s});if(t instanceof ShadowRoot){if(!t[d]){t[d]=document.createElement("adopted-stylesheets");t.appendChild(t[d])}t[d].appendChild(s)}else{t.appendChild(s)}if(s.sheet){for(const t of o[e].pastActions){if(t.type==="method"){s.sheet[t.key](...t.args)}}}return s};const y=t=>{t[e]._adopters.forEach(o=>{o.clone.innerHTML=t[e]._sheet.innerHTML})};class S{constructor(){this._adopters=[];this.pastActions=[];const t=document.createElement("style");p.appendChild(t);this._sheet=t;t.sheet[e]=this;if(!t.sheet.constructor.prototype.replace){t.sheet.constructor.prototype.replace=s;t.sheet.constructor.prototype.replaceSync=o}return t.sheet}}StyleSheet.prototype.replace=s;CSSStyleSheet.prototype.replace=s;CSSStyleSheet.prototype.replaceSync=o;StyleSheet.prototype.replaceSync=o;function n(t){const o=CSSStyleSheet.prototype[t];CSSStyleSheet.prototype[t]=function s(...n){if(e in this){this[e]._adopters.forEach(e=>{e.clone.sheet&&e.clone.sheet[t](...n)});this[e].pastActions.push({type:"method",key:t,args:n})}return o.call(this,...n)}}n("addImport");n("addPageRule");n("addRule");n("deleteRule");n("insertRule");n("removeImport");n("removeRule");window.CSSStyleSheet=S;const u={get(){return this._adopted||[]},set(t){const o=this.body?this.body:this;this._adopted=this._adopted||[];const s=new MutationObserver(i);s.observe(this,{childList:true});if(!Array.isArray(t)){throw new TypeError("Adopted style sheets must be an Array")}t.forEach(e=>{if(!e instanceof CSSStyleSheet){throw new TypeError("Adopted style sheets must be of type CSSStyleSheet")}});const n=[...new Set(t)];const r=this._adopted.filter(e=>!n.includes(e));r.forEach(t=>{const s=t[e]._adopters.filter(e=>e.location===o)[0].clone;s[c]=true;s.parentNode.removeChild(s)});this._adopted=n;if(this.isConnected){t.forEach(e=>a(this,e))}}};Object.defineProperty(ShadowRoot.prototype,"adoptedStyleSheets",u);Object.defineProperty(Document.prototype,"adoptedStyleSheets",u)}})(undefined);
